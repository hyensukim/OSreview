# 컴퓨터 성능 향상 기술 발전의 배경
- 현대 컴퓨터 구조의 가장 큰 문제는 CPU와 메모리, 주변장치의 작업 속도가 다르다는 것이다.
- 메모리를 비롯한 주변장치의 속도가 CPU의 속도를 따라가지 못한다.
- 이러한 장치 간 속도 차이를 개선하고 시스템의 작업 속도를 올리기 위해 기술이 개발되었다.

# 1. 버퍼
## 개념
- 버퍼 : 두 장치 사이의 속도 차이를 완화하는 장치로서, 일정량의 데이터를 모아서 옮겨 속도 차이를 완화한다.
- 버퍼의 사용
    - 하드디스크 - 버퍼 메모리 사용.
    - 소프트웨어 - 동영상 스트리밍

## 스풀(SPOOL)
- CPU와 입출력장치가 독립적으로 동작하도록 고안된 소프트웨어적인 버퍼.
- 대표 예시 : 프린터 - 스풀러
    - 스풀러를 사용하면 인쇄할 내용을 하드디스크의 스풀러 공간에 저장하고 워드 프로세서는 다른 작업이 가능하다.
- 버퍼와 다른점
    - 버퍼는 프로그램이 공유하여 사용하기 때문에 버퍼가 다 차면 데이터를 옮긴다.
    - 스풀러는 인쇄 작업이 완료될 때까지 다른 작업이 끼어들 수 없도록 프로그램 간에 배타적이다.

## 캐시(Cache)
- 캐시는 메모리와 CPU 간의 속도 차이를 완화하기 위해 메모리의 데이터를 미리 가져와 저장하는 임시 저장소이다.
- 캐시는 CPU 내부에 내장되어 있어 CPU 내부 버스의 속도로 작동한다.
- CPU가 메모리 접근 전 캐시에서 원하는 데이터를 찾으면 '캐시히트'라고 하고, 못 찾으면 '캐시미스'라고 한다.
- 캐시히트 되는 비율을 '캐시 적중률'이라고 하며, 일반적인 컴퓨터의 캐시 적중률은 대략 90%이다.

### 캐시 적중률 높이는 법
- 컴퓨터의 성능과 캐시 적중률은 비례관계이다.
- 캐시 적중률을 높이는 법 2가지
    1. 캐시 크기 늘리는 것.
        - 가격이 비싸 한계가 있다.
    2. 지역성 이론에 따라 데이터를 가져오는 것.
        - 지역성 이론 : 현재 실행중인 프로그램의 위치에서 가까운 데이터가 멀리있는 데이터보다 다음에 실행될 확률이 높다는 이론.

### 캐시 내 데이터 변경 시 메모리 반영 방법
1. 즉시 쓰기 : 캐시 내 데이터 변경 시 메모리에 바로 반영하는 방식.
    - 메모리에 잦은 데이터 전송으로 인해 시스템 성능은 떨어지지만, 캐시 내 데이터와 메모리의 데이터가 항시 일치한다.
2. 지연 쓰기 : 캐시에 있는 데이터가 변경되면 그 내용을 모아서 주기적으로 반영하는 방식.(카피백)
    - 시스템 성능을 향상시킬 수 있지만, 캐시 내 데이터와 메모리 사이의 불일치가 발생.

### 레벨별 캐시
- 일반 캐시(Level2) : 명령어와 데이터 구분 없이 모든 데이터를 가져오는 캐시, 메모리와 연결됨.
- 특수 캐시(Level1) : 명령어와 데이터를 구분하여 가져오는 캐시, CPU 레지스터에 직접 연결됨.

### 웹브라우저 캐시
- 웹에서 사용하는 캐시는 앞으로 다시 방문할 것을 예상하여 지우지 않는 데이터를 의미한다.
- 방문했던 사이트의 데이터를 보관하여 재방문 시 실행 속도를 높이는 역할을 한다.
<br><br>

# 2. 저장장치의 계층구조
- 속도가 빠르고 값이 비싼 저장장치를 CPU 가까운쪽에 두고, 값이 싸고 용량이 큰 저장장치를 메모리쪽에 배치하여 적당한 가격
  으로 빠른 속도와 큰 용량을 동시에 얻는 방법.
- 문제점은 저장장치의 계층 구조는 중복되는 데이터의 일관성을 유지하는 것이 완전 보장되지는 않는다.
    - 저렴한 가격으로 최대한의 성능을 갖기 위해서 캐시에 저장된 데이터를 메모리에 반영하는 방식으로 지연 쓰기를 사용하게 된다.
    - 지연쓰기를 사용할 경우 캐시와 메모리의 데이터 간의 불일치가 발생할 수 있다.
<br><br>

# 3. 인터럽트
## 개념
- 초기의 컴퓨터 시스템에는 주변장치가 많지 않았다.
- **폴링 방식** : 주변장치가 적어 CPU가 직접 입출력장치에서 데이터를 가져오거나 내보냈던 방식.
- 위 방식은 CPU 본래의 작업 이외의 모든 입출력 장치에 관여해야 하므로 작업효율이 떨어진다.
- 현대 컴퓨터의 주변장치 갯수는 많아져 CPU가 모두 관여하기에 작업 효율이 현저하게 떨어지게 된다.
- 이를 해결하기 위해 등장한 것이 '인터럽트 방식'이다.
- **인터럽트 방식** : CPU의 작업과 저장장치의 데이터 이동을 독립적으로 운영함으로서 시스템의 성능을 높인다.

## 인터럽트 방식의 동작 과정
1. CPU가 입출력 관리자에게 입출력 명령(제어 신호)을 보낸다.
2. 입출력 관리자는 명령받은 데이터를 메모리에 가져다 놓거나 메모리에 있는 데이터를 저장장치로 옮긴다.
3. 데이터 전송이 완료되면 입출력 관리자는 CPU에 완료 신호를 보낸다.
- 이때 보내는 완료신호가 '인터럽트'이다.
- CPU는 입출력 관리자에게 작업 지시 후 다른 일을 하다가 인터럽트 발생 시 하던 일을 중단하고 옮겨진 데이터를 처리한다.
- 인터럽트 번호 : 많은 주변장치 중 어떤 장치의 작업이 끝났는지를 CPU에 알려주기 위한 번호.(장치의 이름 대신 고유번호를 보내며, 이는 운영체제마다 다르다.)
- CPU가 여러 작업을 지시한 경우, 여러 작업이 동시에 완료되고 그때마다 인터럽트를 발생하면 매우 비효율적이기 떄문에 인터럽트를 하나의 배열인 '인터럽트 벡터'
  로 만들어 CPU에게 알릴 때 사용한다.
- 다양한 종류의 인터럽트
    - 사용자가 전원 버튼을 눌러 강제 종료하는 경우.
    - 메모리 영역을 넘은 작업인 경우 또는 0으로 숫자를 나누는 경우.
<br><br>

# 4. 직접 메모리 접근
- 메모리는 본래 CPU만 접근 권한을 가지므로 입출력 관리자는 접근이 불가능하다.
- 하지만 인터럽트 방식의 시스템 구성을 위해 입출력 관리자가 메모리에 직접 접근하는 것이 필요하다.
- 따라서 입출력 관리자에게 CPU의 허가 없이 메모리에 접근할 수 있는 권한(직접 메모리 접근)을 부여한다.
<br><br>

# 5. 메모리 맵 입출력
- 직접 메모리 접근을 사용하게 되면, 메모리 내부는 CPU가 사용하는 데이터와 입출력 장치가 사용하는 데이터가 섞이게 되어 복잡해진다.
- 이를 막기 위해 메모리를 나누어 일정 공간을 입출력에 할당하는 기법을 '메모리 맵 입출력'이라고 한다.
<br><br>

# 6. 사이클 훔치기
- CPU와 직접 메모리 접근이 동시에 메모리에 접근하는 경우가 발생할 수 있다.
- 이와 같은 경우, CPU 작업 속도가 입출력장치 속도보다 빠르기 때문에 CPU가 메모리 사용 권한을 양보하는데, 이러한 상황을 '사이클 훔치기'라고 부른다.